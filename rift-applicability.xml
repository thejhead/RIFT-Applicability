<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">


<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="no"?>
<?rfc subcompact="no"?>
<?rfc authorship="yes"?>
<?rfc tocappendix="yes"?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" category="info" ipr='trust200902' tocInclude="true"  obsoletes="" updates="" consensus="true" submissionType="IETF" xml:lang="en" version="3" docName="draft-ietf-rift-applicability-01">

<front>

<title abbrev='RIFT Applicability Statement'>RIFT Applicability</title>

<author fullname='Yuehua Wei' initials='Yuehua' surname='Wei' role='editor' >
<organization>ZTE Corporation</organization>
<address>
<postal>
<street>No.50, Software Avenue</street>

<city>Nanjing</city>

<region/>

<code>210012</code>

<country>China</country>
</postal>

<email>wei.yuehua@zte.com.cn</email>
</address>
</author>

<author fullname='Zheng Zhang' initials='Zheng' surname='Zhang'>
<organization>ZTE Corporation</organization>
<address>
<postal>
<street>No.50, Software Avenue</street>

<city>Nanjing</city>

<region/>

<code>210012</code>

<country>China</country>
</postal>

<email>zzhang_ietf@hotmail.com</email>
</address>
</author>

<author fullname='Dmitry Afanasiev' initials='Dmitry' surname='Afanasiev'>
<organization>Yandex</organization>
<address>
<postal>
<street/>

<city/>

<region/>

<code/>

<country/>
</postal>

<email>fl0w@yandex-team.ru</email>
</address>
</author>

<author fullname='Tom Verhaeg' initials='Tom' surname='Verhaeg'>
<organization>Juniper Networks</organization>
<address>
<postal>
<street/>

<city/>

<region/>

<code/>

<country/>
</postal>

<email>tverhaeg@juniper.net</email>
</address>
</author>


<author fullname='Jaroslaw Kowalczyk' initials='Jaroslaw' surname='Kowalczyk'>
<organization>Orange Polska</organization>
<address>
<postal>
<street/>

<city/>

<region/>

<code/>

<country/>
</postal>

<email>jaroslaw.kowalczyk2@orange.com</email>
</address>
</author>

  <author fullname='Pascal Thubert' initials='P.' surname='Thubert'>
      <organization abbrev='Cisco Systems'>Cisco Systems, Inc</organization>
      <address>
         <postal>
            <street>Building D</street>
            <street>45 Allee des Ormes - BP1200 </street>
            <city>MOUGINS - Sophia Antipolis</city>
            <code>06254</code>
            <country>FRANCE</country>
         </postal>
         <phone>+33 497 23 26 34</phone>
         <email>pthubert@cisco.com</email>
      </address>
   </author>
<author fullname='Jordan Head' initials='J' surname='Head'>
<organization>Juniper Networks</organization>
<address>
<postal>
<street/>

<city/>

<region/>

<code/>

<country/>
</postal>

<email>jhead@juniper.net</email>
</address>
</author>

<date/>

<area>Routing</area>
<workgroup>RIFT WG</workgroup>
<keyword>RIFT</keyword>
<abstract>
<t>
This document discusses the properties, applicability and operational considerations
    of RIFT in different
network scenarios. It intends to provide a
rough guide how RIFT can be deployed to simplify routing operations in
Clos topologies and their variations.
</t>
</abstract>
</front>

<!-- ***** MIDDLE MATTER ***** -->

<middle>
<section><name>Introduction</name>

<t>This document intends to explain the properties and applicability of
<xref target='I-D.ietf-rift-rift'>"Routing in Fat Trees"</xref> in different
deployment scenarios and highlight the operational simplicity of the technology compared
to traditional routing solutions. It also documents special considerations when RIFT is
    used with or without overlays, controllers and identifies topology mis-cablings and/or node and
    link failures.
</t>

</section>

<section><name>Problem Statement of Routing in Modern IP Fabric Fat Tree Networks</name>

<t>Clos and Fat-Tree topologies have gained prominence in today's networking, primarily
as result of the paradigm shift towards a centralized data-center based architecture that
is poised to deliver the majority of compute and storage services in the future.
</t>

<t>Current routing protocols are geared toward a network with an ierregular topology and 
low degree of connectivity. Challenges arise when these protocols are applied to Fat-Tree topologies:
</t>

    <ul>
            <li>Extensive configuration is required during initial provisioning and scaling efforts.</li>
            <li>Spine and leaf nodes are required to store all network topology and routing
            information.  Leaf nodes do not require this for normal operation.</li>
            <li>Protocol scalability, bandwidth, and control plane processing are all negatively
            impacted due to duplication of routing information flooded between spine and leaf nodes.</li>
    </ul>
</section>


<section><name>Applicability of RIFT to IP Fabrics</name>

<t>
Further content of this document assumes that the reader is
familiar with the
terms and concepts used in <xref target='RFC2328'>OSPF</xref>, 
<xref target='ISO10589-Second-Edition'>IS-IS</xref>, 
<xref target='I-D.ietf-rift-rift'>RIFT</xref>.
</t>
<section><name>Overview of RIFT</name>
<t>RIFT is a dynamic routing protocol for Clos and fat-tree network topologies.
It defines a link-state protocol behavior when "pointing north" and distance vector 
protocol behavior when "pointing south".
</t>

<t>It floods flat link-state information northbound only so that each level
obtains the full topology of levels south of it. Routing information flooded northbound 
is never re-flooded to south nodes or east-west nodes (when applicable).  Top-of-Fabric 
nodes will have a full view of the topology (i.e. all prefixes) once SPF calculation is 
complete.
</t>

<t>In the southbound direction the protocol operates like a fully summarizing, unidirectional 
distance vector protocol with an implicit split horizon mechanism.  Routing information (usually 
just a default route) propagates one hop south and is re-originated by those nodes at the lower 
level in the same manner.
</t>

     <figure align='center' anchor='pic-rift'><name>Rift overview</name>
        <artwork align='center'><![CDATA[

          +-----------+          +-----------+
          |  ToF21    |          |   ToF22   |         LEVEL 2
+         +-----+--+--+          +-+--+------+
|         |     |  |  |          | |  |      |      ^
+         |     |  |  +-------------------------+   |
Distance  |  +-------------------+ |  |      |  |   |
Vector    |  |  |  |               |  |      |  |   +
South     |  |  |  |      +--------+  |      |  |   Link State
+         |  |  |  |      |           |      |  |   Flooding
|         |  |  +-------------+       |      |  |   North
v         |  |     |      |   |       |      |  |   +
        +-+--+-+   +------+   +-------+   +--+--+-+ |
        | S111 |   | S112 |   | S121  |   | S122  | |  LEVEL 1
+       ++----++   ++---+-+   +--+--+-+   ++----+-+ |
+        |    |     |   |        |  |      |    |   |      ^ N
Distance |    +-------+ |        |  +--------+  |   |      |   E
Vector   |          | | |        |         | |  |   |  <------->
South    |  +-------+ | |        | +-------+ |  |   |  W   |
+        |  |         | |        | |         |  |   |    S v
v       ++--++      +-+-++      ++-+-+     +-+--++  +
        |L111|      |L112|      |L121|     |L122 |     LEVEL 0
        +----+      +----+      +----+     +-----+

         ]]></artwork>
     </figure>

<t>A middle tier node has only information necessary for its level, which are all
destinations south of the node based on SPF calculation, default route and
potential disaggregated routes.
</t>

<t>RIFT combines the advantages of both link-state and distance vector protocols:
</t>
<ul>
            <li>Fastest possible convergence</li>
            <li>Automatic detection of topology</li>
            <li>Minimal routing information on leaves/ToRs</li>
            <li>High degree of ECMP</li>
            <li>Fast de-commissioning of nodes</li>
            <li>Fast and efficient convergence</li>
</ul>

<t>RIFT improves upon existing disadvantages of link-state and distance vector protocols by:
</t>

    <t>
        </t><ul>
            <li>Reducing flooding scope to a minimum</li>
            <li>Automatically detecting neighbors</li>
        </ul><t>
    </t>

<t>There are many more operational advantages that are outlined in greater detail 
in <xref target='I-D.ietf-rift-rift'>RIFT</xref>.
</t>
<ul>
            <li>"True" ZTP implementation that doesn't require any configuration and 
            can identify mis-cabling errors.</li>
            <li>Minimum possible blast radius on failures due to nodes only containing 
            relevant routing information and automatic route disaggregation.</li>
            <li>Simplified leaf implementations that can scale down to servers.</li>
            <li>Horizontal (east/west) links can be implemented for improved fault tolerance.</li>
            <li>Utilizes all viable loop-free paths through the fabric.</li>
            <li>Supports both equal cost and non-equal cost multipath load-balancing.</li>
            <li>Asymmetric bandwidth adjustments are possible.</li>
            <li>Inherent control plane security.</li>
</ul>

    <section><name>South Reflection</name>
    <t>South reflection is the mechanism where South TIEs are reflected back 
    toward the north, allowing nodes to be aware of other nodes in the same level.
    </t>
    <t>Referring to the example in Figure 1, Spine111\Spine112\Spine121\Spine122 will 
    reflect Node S-TIEs from ToF21 to ToF22 and also from ToF22 to ToF21.  The result 
    will be that ToF21 and ToF22 will see each others level 2 node information.
    </t>
    </section>

    </section>

<section><name>Applicable Topologies</name>

<t>
Albeit RIFT is designed primarily for "proper" Clos or fat tree topologies, it also 
supports topologies with multiple PoDs (point-of-delivery) and multi-plane fabrics.
</t>
<t>The specification explains the support of multi-plane fabrics by implementing a set of 
rings to allow the protocol to reconcile the full topological view of the different planes.  
This is the most desirable as it makes RIFT's disaggregation capabilities viable in different 
failure scenarios (e.g. fallen leaves).
</t>

<section><name>Directed Acyclic Graph Concepts</name>
<t>
RIFT is an anisotropic routing protocol, meaning that it has a sense of direction (Northbound, Southbound, East, West) and that it operates differently depending on the direction.
</t>
<ul>
<li>
Northbound, RIFT operates as a Link State IGP, whereby the control packets are reflooded first all the way North and only interpreted later. All the individual fine grained routes are advertised.
</li>
<li>
  <t>
  Southbound, RIFT operates as a Distance Vector IGP, whereby the control packets are flooded only one hop, interpreted, and the consequence of that computation is what gets flooded on more hop South. In the most common use-cases, a ToF node can reach most of the prefixes in the fabric. If that is the case, the ToF node advertises the fabric default and disaggregates the prefixes that it cannot reach. On the oethr hand, a ToF Node that can reach only a small subset of the prefixes in the fabric will preferably advertise those prefixes and refrain from aggregating.
  </t>
  <t>
  In the general case, what gets advertised South is in more details:
  </t>
  <ol>
  <li>A fabric default that aggregates all the prefixes that are reachable within the fabric, and that could be a default route or a prefix that is dedicated to this particular fabric.
  </li>
  <li>The loopback addresses of the Northbound nodes, e.g., for inband management.
  </li>
  <li>The disaggregated prefixes for the dynamic exceptions to the fabric Default, advertised to route around the black hole that may form
  </li>
  </ol>
</li>
<li>East-West routing can optionally be used, with specific restrictions. It is useful in particular when a sibling has access to the fabric default but this node does not.
</li>
</ul>
  <t>
  A Directed Acyclic Graph (DAG) provides a sense of North (the direction of the DAG) and of South (the reverse), which can be used to apply RIFT. For the purpose of RIFT an edge in the DAG that has only incoming vertices is a ToF node.

  </t><t>
  There are a number of caveats though:
  </t>
  <ul>
  <li>The DAG structure must exist before RIFT starts, so there is a need for a companion protocol to establish the logical DAG structure.
  </li>
  <li>A generic DAG does not have a sense of East and West. The operation specified for East-West links and the Southbound reflection between nodes are not applicable.
  </li>
  <li>
  In order to aggregate and disaggregate routes, RIFT requires that all the ToF nodes share the full knowledge of the prefixes in the fabric. This can be achieved with a ring as suggested by the RIFT main specification, by some preconfiguration, or using a synchronization with a common repository where all the active prefixes are registered.
  </li>
  </ul>
</section>

<section><name>East-West Links</name>
<t>
RIFT is not purely limited to Clos networks with PoDs and/or multiple planes.  It also 
supports horizontal links below the top-of-fabric level to be used as routes of last resort 
when a node loses all northbound links or cannot compute a default route through them.  
Or, in the case of multiple planes, at the top-of-fabric level to exchange northbound routing 
information between planes (these will links will NEVER be used for forwarding.)
</t>
<t>A possible configuration is a "ring" of horizontal links
at a level. In presence of such a "ring" in any level (except ToF level)
neither N-SPF nor S-SPF will provide a "ring-based protection"
scheme since such a computation would have to deal necessarily
with breaking of "loops" in Dijkstra sense; an application for which RIFT is not intended.
</t>
<t> Nodes at the same level can be connected as a full-mesh, which allows N-SPF 
to provide fault tolerance to any node that has lost its northbound adjacencies 
(as long as any of the other east-west connected nodes have at least one northbound adjacency).
</t>
</section>

<section><name>Vertical Shortcuts</name>
<t>
Through relaxations of the specified adjacency formation rules,
RIFT implementations can be extended to support vertical "shortcuts" between levels as
proposed by <xref target='I-D.white-distoptflood'/>. The RIFT specification
itself does not provide the exact details since the resulting solution suffers from
either much larger blast radius with increased flooding volumes or
in case of maximum aggregation routing bow-tie problems.
</t>
</section>


</section>
</section>
<section><name>Use Cases</name>

<section><name>Data Center Fabrics</name>
<t>
RIFT's creation was driven primarily by Clos based data center underlay 
networks and is clearly suited for that role.  RIFT addresses many of the common 
operational issues in these networks (as outlined in <xref target='opex'/>).
</t>
<t>
Data centers typically have the most densely connected Clos topologies, especially when 
they are considered non-blocking (i.e. when no oversubscription exists).  As These 
networks scale, the cabling requirements increase dramatically.  For example, a 3-stage 
non-blocking Clos network where each stage has 24 nodes and each node has 24 ports would 
contain 1152 physical connections.  Troubleshooting deployments of this scale is difficult 
and time consuming, both logically and physically.  Operators are then forced to develop 
additional software tools in order to address this problem (or incur significant delays).  
RIFT can identify mis-cabled connections natively, thereby reducing operational and development 
costs.
</t>
</section>

<section><name>Metro Fabrics</name>
<t>
The demand for bandwidth is increasing steadily and is not only driven by environments 
in close proximity to content providers (e.g. data centers), but also by environments 
n close proximity to content consumers as well (e.g. end users).  These environments are 
typically clustered in metro areas with their own network architectures that can benefit 
from simplified Clos topologies.
</t>
</section>

<section><name>Enterprise Fabrics</name>
<t>
Commercial buildings are often cabled in a similar manner to that of a Clos or an isomorphic 
equivalent.  As the number of floors grow, the control plane scale requirements to support the 
Clos (or Clos-like) topology grows as well.  This presents a challenge for traditional IGPs 
that do not support an arbitrary number of levels (which RIFT does naturally).  Moreover, 
hardware deployed in enterprise networks are not quite as powerful as their counterparts 
in data center deployments.  Under normal conditions, RIFT can prove particularly cost effective 
in this area in that it maintains only the minimum RIB/FIB required and control plane 
traffic required to converge is less than that of other IGPs.
</t>
</section>

<section><name>CloudCO</name>
<t>
The Cloud Central Office (CloudCO) is a new stage of telecom Central Office. It takes advantage of Software Defined Networking (SDN) and Network Function Virtualization (NFV) in conjunction with general purpose hardware to optimize current networks.
The following figure illustrates this architecture at a high level. It describes a single instance or macro-node of cloud CO. An Access I/O module faces a Cloud CO Access Node, and the CPEs behind it. A Network I/O module is facing the core network. The two I/O modules are interconnected by a leaf and spine fabric. <xref target='TR-384'/> 
RIFT fits well into the typical spine-leaf deployments in a CloudCO, as the architecture needs to be adaptable, agile, scalable, and dynamic.
</t>
    <figure align='center' anchor='pic-CloudCO'><name>An example of CloudCO architecture</name>
        <artwork align='center'><![CDATA[
+---------------------+           +----------------------+
|         Spine       |           |     Spine            |
|         Switch      |           |     Switch           |
+------+---+------+-+-+           +--+-+-+-+-----+-------+
|      |   |      | | |              | | | |     |       |
|      |   |      | | +-------------------------------+  |
|      |   |      | |                | | | |     |    |  |
|      |   |      | +-------------------------+  |    |  |
|      |   |      |                  | | | |  |  |    |  |
|      |   +----------------------+  | | | |  |  |    |  |
|      |          |               |  | | | |  |  |    |  |
|  +---------------------------------+ | | |  |  |    |  |
|  |   |          |               |    | | |  |  |    |  |
|  |   |   +-----------------------------+ |  |  |    |  |
|  |   |   |      |               |    |   |  |  |    |  |
|  |   |   |      |   +--------------------+  |  |    |  |
|  |   |   |      |   |           |    |      |  |    |  |
+--+ +-+---+--+ +-+---+--+     +--+----+--+ +-+--+--+ +--+
|L | | Leaf   | | Leaf   |     |  Leaf    | | Leaf  | |L |
|S | | Switch | | Switch |     |  Switch  | | Switch| |S |
++-+ +-+-+-+--+ +-+-+-+--+     +--+-+--+--+ ++-+--+-+ +-++
 |     | | |      | | |           | |  |     | |  |     |
 |   +-+-+-+--+ +-+-+-+--+     +--+-+--+--+ ++-+--+-+   |
 |   |Compute | |Compute |     | Compute  | |Compute|   |
 |   |Node    | |Node    |     | Node     | |Node   |   |
 |   +--------+ +--------+     +----------+ +-------+   |
 |   || VAS5 || || vDHCP||     || vRouter|| ||VAS1 ||   |
 |   |--------| |--------|     |----------| |-------|   |
 |   |--------| |--------|     |----------| |-------|   |
 |   || VAS6 || || VAS3 ||     || v802.1x|| ||VAS2 ||   |
 |   |--------| |--------|     |----------| |-------|   |
 |   |--------| |--------|     |----------| |-------|   |
 |   || VAS7 || || VAS4 ||     ||  vIGMP || ||BAA  ||   |
 |   |--------| |--------|     |----------| |-------|   |
 |   +--------+ +--------+     +----------+ +-------+   |
 |                                                      |
++-----------+                                +---------++
|Network I/O |                                |Access I/O|
+------------+                                +----------+
                        ]]>
            </artwork>
        </figure>

</section>

<section><name>Internal Router Switching Fabrics</name>
<t>
It is common in high-speed communications switching and routing
devices to use fabrics when a crossbar is not feasible due to cost,
head-of-line blocking
or size trade-offs. Normally such fabrics are not self-healing or rely
on 1:/+1 protection schemes, but it is conceivable to use RIFT to
operate Clos fabrics that can effectively deal with interconnection
or subsystem failures in such cases. RIFT is not IP specific, so any 
link addressing scheme connecting internal subnets is possible.
</t>
</section>

</section>

<section anchor='opex'><name>Deployment Considerations</name>

<t>
RIFT presents the opportunity for organizations building and operating IP fabrics 
to simplify their operational and deployment activities, while achieving many other 
desirable properties associated with dynamic routing protocols in such a substrate:
</t>

<ul>
<li>
RIFT design follows minimum blast radius and minimum necessary
epistemological scope philosophy which leads to very good scaling
properties while delivering maximum reactiveness.
</li>
<li>
RIFT allows for extensive Zero Touch Provisioning within the protocol.
In its most extreme version RIFT does not rely on any specific addressing
and for IP fabric can operate using <xref target='RFC4861'>IPv6 ND</xref> only.
</li>
<li>
RIFT has provisions to detect common IP fabric mis-cabling scenarios.
</li>
<li>
RIFT automatically negotiates BFD on every link, paving the way for IP and 
<xref target='RFC7130'>micro-BFD</xref> to replace LAG/MC-LAG (which can hide 
bandwidth imbalances in failure scenarios).  Further automatic link validation techniques 
such as <xref target='RFC5357'>TWAMP</xref> could be supported as well.
</li>
<li>
RIFT inherently solves many difficult problems associated with the use of 
traditional routing topologies with dense meshes and high degress of ECMP by 
including automatic bandwidth balancing, flood reduction, and automatic route 
disaggregation on failures.
</li>
<li>
RIFT reduces FIB size towards the bottom of the IP fabric where most nodes
reside and with that allows for cheaper hardware at the edge while introducing
modern IP fabric architectures that enable new features (e.g. server multi-homing).
</li>
<li> RIFT provides valley-free
routing that is loop free. This allows the use of any such valley-free
path
in bi-sectional fabric bandwidth between two destinations irrespective of their
metrics, which can be used to load-balance on the fabric in different ways.
</li>
<li>
RIFT includes a key-value distribution mechanism
which allows for many future applications
such as automatic provisioning of basic overlay services or automatic key
roll-overs across entire fabrics.
</li>
<li>
RIFT is designed for minimum delay in case of prefix mobility on the fabric.
</li>
</ul>

    <section><name>Route Disaggregation</name>
    <t>Route disaggregation is the procedure whereby [RIFT] advertises a more specific 
    route southbound in addition to the default route.  It is useful in scenarios 
    where a prefix is reachable by only some of the parent nodes, but not others at 
    the same level in the fabric.  Disaggregation is mandatory on ToF nodes 
    because any ToF node that cannot reach a prefix will blackhole traffic for that 
    prefix.  
    </t>

    <t> There are two types of disaggregation, positive and negative.  Positive disaggregation 
    indicates a nodes ability to reach a given prefix, whereas negative disaggregation indiciates a 
    nodes inability to reach a given prefix.</t>

        <section><name>Positive Disaggregation</name>
        <t>Positive disaggregation occurs as a result of south reflection after a failure due to the fact 
        that nodes at a given level will be aware of reachability information of other nodes 
        at the same level.  Those nodes will see no longer see the prefixes that were imapcted by the failure.  
        This results in the generation of postively disaggregated (more specific) prefix advertisements to southbound 
        nodes, which then use the remaining path(s) toward the disaggregated prefix based on longest prefix match.</t>

        <t>As previously stated, RIFT only maintains routing information necessary for a given level.  
        Positively disaggregated are no different, they are only flooded as far south 
        as necessary.  These routes not being transitive in nature means that positive disaggregation is 
        significantly more scalable in large fabrics.</t>

        <t>During positive disaggregation, the first ToF node to advertise the more specific prefix may transiently 
        receive the majority of the traffic for that prefix until the necessary FIB entries are installed on all ToF nodes.  
        ToP nodes that prefer not to inject the longer prefix in order to receive more advertisements and spread traffic 
        more evenly, will continue to forward traffic to the blackholed destination for a similar period of time.</t>
        </section>

        <section><name>Negative Disaggregation</name>


    <figure align='center' anchor='multiplane-tof-rings'><name>Interfabric Rings</name>
        <artwork align='center'><![CDATA[

        +--------------------------------+
        | +------------------------------|-+
        | |          +-------------------|-|----------+
        | |          | +-----------------|-|----------|-+
        | |          | |                 | |          | |
      +-+-+---+    +-+-+---+           +-+-+---+    +-+-+---+
      |ToF  A1|    |ToF  A2|           |ToF  B1|    |ToF  B2| LEVEL 2
      +-------+    +-------+           +-------+    +-------+
      |       |    |       |           |       |    |       |
      |       |    |       +-----------------+ |    |       |
      |       +--------------------------+   | |    |       |
      |            |                   | |   | |    |       |
      |     +------+                   | |   | +------+     |
      |     |        +-----------------+ |   |      | |     |
      |     |        |   +--------------------------+ |     |
      |     |        |   |               |   |        |     |
      +-----+-+    +-+---+-+           +-+---+-+    +-+-----+
      |Spin111|    |Spin112|           |Spin121|    |Spin122| LEVEL 1
      +-+---+-+    ++----+-+           +-+---+-+    ++----+-+
        |   |       |    |               |   |       |    |
        |   +---------+  |               |   +---------+  |
        |           | |  |               |           | |  |
        |   +-------+ |  |               |   +-------+ |  |
        |   |         |  |               |   |         |  |
      +-+---+-+    +--+--+-+           +-+---+-+    +--+--+-+
      |Leaf111|    |Leaf112+           |Leaf121|    |Leaf122| LEVEL 0
      +-------+    +-------+           +-------+    +-------+
     +--------PoD1----------+         +----------PoD2--------+

                        ]]>
            </artwork>
        </figure>

        <t>Multi-plane fabrics present challenges that positive disaggregation cannot solve.  This is true whether 
        the topology was designed with multiple planes or if failures in a single plane topology resulted in a 
        partitioned fabric.  The challenge arises when a fabric is partitioned and a leaf node loses connectivity 
        through a subset of ToF nodes.  ToF nodes are required to share the same northbound database, this happens 
        naturally in a single plane environment due to northbound flooding and south reflection.  Whereas in multi-plane 
        environments it does not because ToF nodes in one plane will not be aware of another planes leaves.  This lack of 
        prefix information will cause traffic to be blackholed at the ToF nodes or experience suboptimal routing.</t>

        <t><xref target='multiplane-tof-rings'/> illustrates how to resolve this by utilizing two revenue ports on each ToF node to interconnect East-West rings between the 
        other ToF nodes.  The rings will facilitate northbound flooding in both directions so that ToF nodes will learn 
        prefix information from other planes.  This introduces negative disaggregation, ToF nodes can now advertise more specific 
        negatively disaggregated prefixes that indicate that they cannot reach them.  Unlike positive disaggregation's non-transitive 
        properties, negatively disaggregated prefixes are transitive, so they are advertised all the way down to the leaf nodes 
        in the other planes.  This means that there is far more control plane flooding for negatively disaggregated prefixes 
        compared to that of positively disaggregated prefixes.  As nodes receive negatively disaggregated prefixes, they 
        implicitly discern that ports that do not receive them are valid paths and install positively disaggregated routes for those paths.  
        Logic required to build necessary forwarding plane state for negatively disaggregated prefixes is dependent on software 
        implementation and therefore can cause additional churn due to route lookups.</t>

        <t>It is worth noting that single plane implementations would also benefit from the implementation of rings between the ToF nodes 
        to protect against cascading failures where the fabric may become partitioned.  Adding more connectivity between spine 
        and ToF nodes to avoid the partitioning altogether is another option.</t>

        <t>Like positive disaggregation, negative disaggregation also may suffer from transient forwarding concerns.  The last ToF node(s) to 
        inject the negatively disaggregated route may also end up receiving the majority of the traffic for a short period of time.  
        For example, this would occur when a totally unreachable prefix becomes disaggregated, but practically speaking, would not be recommended.</t>
        </section>

    </section>

    <section><name>Suboptimal Routing on Link Failures</name>
        <figure align='center' anchor='pic-suboptimal'><name>Suboptimal routing upon link failure use case</name>
        <artwork align='center'><![CDATA[
               +--------+          +--------+
               | ToF21  |          |  ToF22 |                LEVEL 2
               ++--+-+-++          ++-+--+-++
                |  | | |            | |  | +
                |  | | |            | |  | linkTS8
  +-------------+  | +-+linkTS3+-+  | |  | +--------------+
  |                |   |         |  | |  +                |
  |    +----------------------------+ |  linkTS7          |
  |    |           |   |         +    +  +                |
  |    |           |   +-------+linkTS4+------------+     |
  |    |           |             +    +  |          |     |
  |    |           |     +------------+--+          |     |
  |    |           |     |       |  linkTS6         |     |
+-+----++         ++-----++     ++------+          ++-----++
|Spin111|         |Spin112|     |Spin121|          |Spin122| LEVEL 1
+-+---+-+         ++----+-+     +-+---+-+          ++---+--+
  |   |            |    |         |   |             |   |
  |   +--------------+  |         +   ++XX+linkSL6+---+ +
  |                | |  |      linkSL5              | | linkSL8
  |   +------------+ |  |         +   +---+linkSL7+-+ | +
  |   |              |  |         |   |               | |
+-+---+-+         +--+--+-+     +-+---+-+          +--+-+--+
|Leaf111|         |Leaf112|     |Leaf121|          |Leaf122| LEVEL 0
+-+-----+         ++------+     +-----+-+          +-+-----+
  +                +                  +              +
Prefix111         Prefix112     Prefix121          Prefix122

            ]]></artwork>
        </figure>

    <t>As shown in <xref target='pic-suboptimal'/>, the result of south reflection between 
    Spine121-Leaf121-Spine122 and Spin121-Leaf122-Spine122 will be that Spine121 and Spine122 
    see each other as level 1 nodes.</t>
    <t>Without the disaggregation mechanism, when linkSL6 fails, traffic from Leaf121 to Prefix122 
    may traverse suboptimal paths like linkSL5/linkTS3/linkTS4/linkSL8 or linkSL5/linkTS6/linkTS4/linkSL8 
    (based purely on the default route) to get to Leaf122.  This suboptimal routing pattern is an example of 
    "bow-tieing". </t>
    <t>With the disaggregation mechanism, when linkSL6 fails, Spine122 will detect the failure according
     to the reflected Node S-TIE from Spine121.  Spine122 will then explicitly advertise Prefix122 in a 
     Disaggregated Prefix S-TIE (PrefixesElement(Prefix122, cost 1)).  The traffic from Leaf121 to Prefix122 
     will only traverse linkSL7 (based on longest-prefix match) and then linkSL8 to Leaf122.
    </t>
    </section>

    <section><name>Black-Holing on Link Failures</name>
    <figure align='center' anchor='pic-blackhole'><name>Black-holing upon link failure use case</name>
        <artwork align='center'><![CDATA[
                +--------+          +--------+
                | ToF 21 |          | ToF 22 |                LEVEL 2
                ++-+--+-++          ++-+--+-++
                 | |  | |            | |  | |
                 | |  | |            | |  | linkTS8
  +--------------+ |  +--linkTS3-X+  | |  | +--------------+
  linkTS1          |    |         |  | |  |                |
  |    +-----------------------------+ |  linkTS7          |
  |    |           |    |         |    |  |                |
  |    |      linkTS2   +--------linkTS4-X-----------+     |
  |    |           |              |    |  |          |     |
  |   linkTS5      +-+    +---------------+          |     |
  |    |             |    |       |  linkTS6         |     |
+-+----++          +-+-----+     ++----+-+          ++-----++
|Spin111|          |Spin112|     |Spin121|          |Spin122| LEVEL 1
+-+---+-+          ++----+-+     +-+---+-+          ++---+--+
  |   |             |    |         |   |             |   |
  |   +---------------+  |         |   +----linkSL6----+ |
  linkSL1           | |  |      linkSL5              | | linkSL8
  |   +---linkSL3---+ |  |         |   +----linkSL7--+ | |
  |   |               |  |         |   |               | |
+-+---+-+          +--+--+-+     +-+---+-+          +--+-+--+
|Leaf111|          |Leaf112|     |Leaf121|          |Leaf122| LEVEL 0
+-+-----+          ++------+     +-----+-+          +-+-----+
  +                 +                  +              +
Prefix111          Prefix112     Prefix121          Prefix122
            ]]></artwork>
        </figure>

    <t>The scenario in Figure 4 illustrates a case where a double link failure 
    occurs, resulting in traffic being blackholed.</t>
    <t>Without the disaggregation mechanism, when linkTS3 and linkTS4 fail, 50% of the 
    traffic from Leaf111 toward Prefix122 would be black holed.  The traffic may traverse 
    either linkSL1/linkTS1 or linkSL3/linkTS2 to reach ToF21, but would ultimately be 
    dropped when trying to get to Leaf122 via linkTS3 or linkTS4.</t>
    <t>With the disaggregation mechanism, when linkTS3 and linkTS4 fail, ToF22 will 
    detect the failure according to the reflected Node S-TIE from Spine111/Spine112 
    (representing ToF21).  ToF22 will then explicitly originate an S-TIE with Prefix121 
    and Prefix122, which is then flooded to Spine111/Spine112/Spine121/Spine122.</t>
    <t>Traffic from Leaf111 toward Prefix122 will then be routed toward linkTS5 or linkTS7 
    based on longest-prefix match (instead of linkTS1 or linkTS2)</t>
    </section>

<section><name>Zero Touch Provisioning (ZTP)</name>
<t>RIFT nodes may operate in Zero Touch Provisioning (ZTP) mode allowing RIFT to 
automatically configure a node's level after it is attached to the topology.  ZTP 
allows new devices to be installed and automatically join the topology with little or 
no preconfiguration.  Only deployments utilizing ToF nodes would require intial 
configuration, whereas other implementations such as leaf only without the use of 
leaf-2-leaf procedures, would not.</t>

<t>The most important concept for ZTP is the automatic level derivation procedure.  
All ToF nodes are explicitly marked with the TOP_OF_FABRIC flag which is used by 
other ZTP nodes to derive their own respective levels.  The derivation of the level 
at each node occurs based on information contained in LIEs received from its neighbors.  
Nodes use the information to attach to the highest possible point in the fabric.  
This guarantees that even if LIEs are received from a node at a "lower" level before 
that of a "higher" level, it will ignore the "lower" level's LIEs in order to ensure 
proper connectivity with nodes "above" it.
</t>

    <section><name>LEAF_ONLY Flag</name>
    
    <figure align='center' anchor='Fallen-spine'><name>Fallen spine</name>
        <artwork align='center'><![CDATA[
+-------+    +-------+        +-------+    +-------+
|ToF  A1|    |ToF  A2|        |ToF  A1|    |ToF  A2|    LEVEL 2
+-------+    +-------+        +-------+    +-------+
|       |    |       |                |            |
|    +-------+       |                |            |
+    +  |            |  ====>         |            |
X    X  +------+     |                +------+     |
+    +         |     |                       |     |
+----+--+    +-+-----+                     +-+-----+
|Spine11|    |Spine12|                     |Spine12|    LEVEL 1
+-+---+-+    ++----+-+                     ++----+-+
  |   |       |    |                        |    |
  |   +---------+  |                        |    |
  |           | |  |                        |    |
  |   +-------+ |  |                +-------+    |
  |   |         |  |                |            |
+-+---+-+    +--+--+-+        +-----+-+    +-----+-+
|Leaf111|    |Leaf112|        |Leaf111|    |Leaf112|    LEVEL 0
+-------+    +-------+        +-+-----+    +-+-----+
                                |            |
                                |   +--------+
                                |   |
                              +-+---+-+
                              |Spine11|
                              +-------+
            ]]></artwork>
        </figure>

    <t>If ZTP is being used, the autoderivation mechanism can have counterintuitive results in certain failure scenarios.  
    For example, <xref target='Fallen-spine'/> shows an example of a fallen spine.  In this case, Spine11 would autoderive a level 
    lower than that of Leaf111 and Leaf112.
    </t>
    <t>This can be prevented by setting the LEAF_ONLY flag on devices that are expected to be leaves (Leaf111 and Leaf112).  
    Since level -1 is invalid, Spine11 would not derive a valid level, and will be isolated from the fabric.  Leaf111 and Leaf112 
    could then report the miscabled links to Spine12.  
    </t>

</section>

</section>

<section><name>Miscabling Examples</name>

    <figure align='center' anchor='single-plane-miscabling'><name>A single plane miscabling example</name>
        <artwork align='center'><![CDATA[
  +----------------+              +-----------------+
  |     ToF21      |       +------+      ToF22      |   LEVEL 2
  +-------+----+---+       |      +----+---+--------+
  |       |    |   |       |      |    |   |        |
  |       |    |   +----------------------------+   |
  |   +---------------------------+    |   |    |   |
  |   |   |    |           |           |   |    |   |
  |   |   |    |   +-----------------------+    |   |
  |   |   +------------------------+   |        |   |
  |   |        |   |       |       |   |        |   |
+-+---+-+    +-+---+-+     |     +-+---+-+    +-+---+-+
|Spin111|    |Spin112|     |     |Spin121|    |Spin122| LEVEL 1
+-+---+-+    ++----+-+     |     +-+---+-+    ++----+-+
  |   |       |    |       |       |   |       |    |
  |   +---------+  |     link-M    |   +---------+  |
  |           | |  |       |       |           | |  |
  |   +-------+ |  |       |       |   +-------+ |  |
  |   |         |  |       |       |   |         |  |
+-+---+-+    +--+--+-+     |     +-+---+-+    +--+--+-+
|Leaf111|    |Leaf112+-----+     |Leaf121|    |Leaf122| LEVEL 0
+-------+    +-------+           +-------+    +-------+
            ]]></artwork>
        </figure>

    <t>The RIFT control protocol can discover the physical links automatically and be able to detect cabling that violates fat-tree or Clos topology constraints.
        It react accordingly to such mis-cabling attempts, at a minimum preventing adjacencies between nodes from being formed and traffic from being forwarded on those mis-cabled links.
        Leaf112 will in such scenario use link-M to derive its level (unless it is leaf) and can report links to spines 111 and 112 as miscabled unless the implementations
        allows horizontal links.</t>
    
    <t><xref target='single-plane-miscabling'/> shows a single plane miscabling example, it is a perfect fat-tree fabric except link-M connecting Leaf112 to ToF22.  
    In this case, Leaf112 will use link-M to (incorrectly) derive its level from ToF22 and report the incorrectly cabled link to Spine111 and Spine112.
    </t>

    <figure align='center' anchor='multi-plane-miscabling'><name>A multiple plane miscabling example</name>
        <artwork align='center'><![CDATA[
 +-------+    +-------+           +-------+    +-------+
 |ToF  A1|    |ToF  A2|           |ToF  B1|    |ToF  B2| LEVEL 2
 +-------+    +-------+           +-------+    +-------+
 |       |    |       |           |       |    |       |
 |       |    |       +-----------------+ |    |       |
 |       +--------------------------+   | |    |       |
 |            |                   | |   | |    |       |
 |     +------+                   | |   | +------+     |
 |     |        +-----------------+ |   |      | |     |
 |     |        |   +--------------------------+ |     |
 |  A  |        | B |               | A |        |  B  |
 +-----+-+    +-+---+-+           +-+---+-+    +-+-----+
 |Spin111|    |Spin112|      +----+Spin121|    |Spin122| LEVEL 1
 +-+---+-+    ++----+-+      |    +-+---+-+    ++----+-+
   |   |       |    |        |      |   |       |    |
   |   +---------+  |        |      |   +---------+  |
   |           | |  |      link-W   |           | |  |
   |   +-------+ |  |        |      |   +-------+ |  |
   |   |         |  |        |      |   |         |  |
 +-+---+-+    +--+--+-+      |    +-+---+-+    +--+--+-+
 |Leaf111|    |Leaf112+------+    |Leaf121|    |Leaf122| LEVEL 0
 +-------+    +-------+           +-------+    +-------+

+--------PoD#1----------+       +---------PoD#2---------+
            ]]></artwork>
        </figure>

    <t><xref target='multi-plane-miscabling'/> shows a multi-plane miscabling example.  Since Leaf112 and Spine121 belong to different PoDs via link-W, 
    link-W would be considered mis-cabled and adjacency formation would be prevented.
    </t>
</section>

<section><name>Mobile Edge and Anycast</name>

    <t>
    When a physical or a virtual node changes its point of attachement in
    the fabric from one leaf to another leaf, new routes must be
    installed that supercede the old ones.  Since flooding flows
    Northwards, the nodes (if any) between the previous-leaf and the
    common parent are not immediately aware that the path via previous-
    leaf is obsolete and a stale route may exist for a period of time.  The
    common parent needs to select the most recent route advertisement in
    order to install the correct route via the new leaf node.  This requires
    that the fabric determine the sequence of the movements of the
    mobile node.
    </t>
    <t>
    On one hand, a sequence counter can provide the total order
    for that period, but it will eventually wrap.  On the other hand, a
    timestamp provides a permanent order, but it may miss movements that
    happen too quickly compared to the granularity of the timing information.
    It is not envisioned in the short term that the average fabric
    supports a precision time protocol, and the precision that may be
    available with the <xref target='RFC5905'>Network Time Protocol</xref>, in the order of
    100 to 200ms, may not be necessarily enough to cover all scenarios (e.g. fast
    mobility of a Virtual Machine.
    </t>
    <t>
    The section of <xref target='I-D.ietf-rift-rift'/> titled "Mobility" 
    specifies a hybrid method that combines a sequence counter from the mobile node and a timestamp from
    the network taken at the leaf when the route is injected.  If the
    timestamps of the concurrent advertisements are comparable (i.e.
    more distant than the precision of the timing protocol), then the
    timestamp alone is used to determine the most current routes.  
    Otherwise, the sequence counter from the mobile node, if available, is used.  
    One caveat is that the sequence counter must not
    wrap within the precision of the timing protocol.  Another is that
    the mobile node may not even provide a sequence counter, in which
    case the mobility itself must be slower than the precision of the 
    timing.
    </t>
    <t>
    Mobility must not be confused with anycast.  In both cases, the same
    address is injected in RIFT at different leaves.  In the case of
    mobility only the most current route must be retained, since the mobile
    node changed its point of attachement for a leaf to the next.  In the
    case of anycast, the node may be either multihomed or reachable beyond the 
    fabric via multiple routes that are redistributed to different leaves.  Regardless,
    in the case of anycast, the multiple routes are equally valid
    and should be retained.  Without further information from the
    redistributed routing protocol, it is impossible to sort out a
    movement from a redistribution that happens asynchronously on
    different leaves.  <xref target='I-D.ietf-rift-rift'/> expects that anycast addresses are
    advertised within the timing precision, which is typically the case
    with a low-precision timing and a multihomed node.  Beyond that time
    interval, RIFT interprets the lag as a mobility and only the most current
    route is retained.
    </t>
    <t>
    When using <xref target='RFC8200'>IPv6</xref>, RIFT suggests leveraging<xref target='RFC8505'>"Registration Extensions for IPv6 over Low-Power
    Wireless Personal Area Network (6LoWPAN) Neighbor Discovery (ND)" </xref> as the IPv6 ND
    interaction between the mobile node and the leaf.  This provides not
    only a sequence counter but also a lifetime and a security token that
    may be used to protect the ownership of an address.  When using
    <xref target='RFC8505'/>, the parallel registration of an anycast address to
    multiple leaves is done with the same sequence counter, whereas the
    sequence counter is incremented when the point of attachement
    changes.  This way, it is possible to differentiate a mobile node
    from a multihomed node, even when the mobility happens within the
    timing precision.  It is also possible for a mobile node to be
    multihomed as well, but only change one of its points of
    attachement.
    </t>
</section> <!-- Mobile Edge and Anycast -->

<section><name>Address Family Considerations</name>
    <t>LIEs are exchanged over all links running RIFT to perform Link
   (Neighbor) Discovery.  A node MUST NOT originate LIEs for an address
   family if it does not process received LIEs for that family.  LIEs on
   same link are considered part of the same negotiation independent of
   the address families they support.  An implementation MUST be ready
   to accept TIEs with the same address family that sourced the LIEs.
    </t>

    <section anchor='v4ov6'><name>IPv4 over IPv6</name>
        <t>RIFT allows advertising IPv4 prefixes over IPv6.  The IPv6
        address family is configured via the usual ND mechanisms, at which point IPv4 can use IPv6
        nexthops (analogous to RFC5549).  RIFT provides an indication whether a node is IPv4 forwarding
        capable and implementations are possible where different routing
        tables are computed per address family as long as the computation
        remains loop-free.
        </t>
    
    <figure align='center' anchor='IPV4-o-IPV6'><name>IPv4 over IPv6</name>
        <artwork align='center'><![CDATA[
              +-----+        +-----+
   +---+---+  | ToF |        | ToF |
       ^      +--+--+        +-----+
       |      |  |           |     |
       |      |  +-------------+   |
       |      |     +--------+ |   |
       |      |     |          |   |
      V6      +-----+        +-+---+
   Forwarding |SPINE|        |SPINE|
       |      +--+--+        +-----+
       |      |  |           |     |
       |      |  +-------------+   |
       |      |     +--------+ |   |
       |      |     |          |   |
       v      +-----+        +-+---+
   +---+---+  |LEAF |        | LEAF|
              +--+--+        +--+--+
                 |              |
    IPv4 prefixes|              |IPv4 prefixes
                 |              |
             +---+----+     +---+----+
             |   V4   |     |   V4   |
             | subnet |     | subnet |
             +--------+     +--------+
            ]]></artwork>
        </figure>

    </section>
</section>

<section><name>In-Band Reachability of Nodes</name>
	<t>RIFT doesn't require that nodes in the fabric have reachable addresses.  However, there are operational purposes that may require such access.
	</t>
    <figure align='center' anchor='In-band-reach'><name>In-Band reachability of node</name>
        <artwork align='center'><![CDATA[
+-------+      +-------+
| ToF1  |      | ToF2  |
++---- ++      ++-----++
 |     |        |     |
 |     +----------+   |
 |     +--------+ |   |
 |     |          |   |
++-----++      +--+---++
|SPINE1 |      |SPINE2 |
++-----++      ++-----++
 |     |        |     |
 |     +----------+   |
 |     +--------+ |   |
 |     |          |   |
++-----++      +--+---++
| LEAF1 |      | LEAF2 |
+---+---+      +-------+
    |
    |NMS

            ]]></artwork>
        </figure>
    <t><xref target='In-band-reach'/> shows an example of a NMS (Network Monitoring System) attaching to LEAF1.  
    The NMS will have reachability to all of the nodes, however it may take suboptimal paths through the fabric.</t>

    <t>  
    If the NMS needs to access LEAF2's loopback address for monitoring purposes, the best path will be taken as LEAF2's loopback address is flooded in its N-TIEs.  
    Consider that the NMS needs to access SPINE2's loopback address, while that address will be flooded by SPINE2 in its N-TIEs, not all resulting paths are optimal.  
    NMS could reach SPINE2 via either LEAF1-SPINE2 (which is preferred), LEAF1-SPINE1-ToF1-SPINE2, or LEAF1-SPINE1-ToF2-SPINE2.  Similarly, if the NMS were to need access 
    to ToF2's loopback address, the resulting traffic may transit ToF1.  To facilitate direct reachability for situations that require it, the loopback addresses 
    of any nodes can be advertised in N-TIEs and S-TIEs.  This allows nodes to have the most specific routes toward the loopback addresses.</t>

</section>

<section><name>Server Connectivity to the Fabric</name>

    <t>Though not always the case, servers are typically connected to IP fabrics via L2 and do not participate in the underlay network's routing protocol.  Routing on the host is becoming more common and running RIFT on servers in 
    order to participate directly in the underlay as leaf nodes may be beneficial.  Additionally, RIFT supports multihoming in either scenario.</t>

    <t>There are various factors that operators should consider when decided whether servers should reside in the underlay or not.
    A detailed overview of these factors is outside the scope of this document, however a brief overview is useful.</t>
    <ul>
    <li>Servers running RIFT in the underlay can manage their own overlay tunnels, thereby reducing feature complexity required RIFT nodes connected to them (e.g. VXLAN).  
    Conversely, operators may also find it beneficial to offload overlay tunnel mechanisms to RIFT nodes if server functions are not the responsibility of the operator.</li>
    <li>Servers running RIFT in the underlay can leverage RIFT's ZTP mechanisms to manage aspects of deployment and provisioning.  However, this may not be desirable depending upon 
    staffing responsibilities.</li>
    </ul>

<section><name>Multihoming Servers</name>

    <figure align='center' anchor='dualhoming-servers'><name>Multihoming servers</name>
        <artwork align='center'><![CDATA[
    +---+         +---+         +---+
    |ToF|         |ToF|         |ToF|
    +---+         +---+         +---+
    |   |         |   |         |   |
    |   +----------------+      |   |
    |             |   |  |      |   |
    |          +----------------+   |
    |          |  |   |  |          |
    +----------+--+   +--+----------+
    | Spine|ToR1  |   | Spine|ToR2  |
    +--+------+---+   +--+-------+--+
+---+  |      |   |   |  |       |  +---+
|      |      |   |   |  |       |      |
|   +-----------------+  |       |      |
|   |  |   +-------------+       |      |
|   |  |   |  |   |---------X-------+   |
X   |  X   |  +--------X-----+   |  |   |
|   |  |   |                 |   |  |   |
+---+  +---+                 +---+  +---+
|   |  |   |                 |   |  |   |
+---+  +---+  .............  +---+  +---+
SV(1) SV(2)                 SV(n+1) SV(n)
            ]]></artwork>
        </figure>

    <t>RIFT supports the multihoming of servers, which has clear advantages in terms of service availability.  Consider a typical server deployment in a data center where servers are single homed to a ToR.  
    Activities like ToR maintenance or even common failures can leave servers completely isolated, the result of the isolation is often service impact.  Multihoming removes these problems.</t>

    <t>Multihoming servers may also require further consideration, such as larger FIB sizes on servers.  A worst case scenario is where all multihomed servers at the same level become disaggregated from each other.  
    Consider the single plane fabric in <xref target='dualhoming-servers'/> where ToR1 loses connectivity to all leaves (servers), all server prefixes would become disaggregated resulting in rapic FIB expansion of n-1 of more specific routes.  
    One way to manage situations like this would be to disaggregate ToR to server connectivity from the start.  Servers could contain a couple tens of routes in addition to the default to prevent outages and unnecessary flooding.</t>

</section>

    <section><name>Securing Servers</name>
    <t>As previously stated, typical server connectivity to an IP fabric is done with layer 2.  This presents an attack vector that RIFT can easily address with 
    its built-in security mechanisms and extending it to the host.  Section 4.4 of the <xref target='I-D.ietf-rift-rift'>RIFT</xref> main specification, details additional security concepts.</t>
    </section>

</section>
<section><name>Fabrics with a Controller</name>
    <t>There are different methods to deploy a controller, two possibilities are to attach it to the ToF nodes or to a leaf node.
    </t>

    <figure align='center' anchor='Fabric-controller'><name>Fabric with a controller</name>
        <artwork align='center'><![CDATA[
                 +------------+
                 | Controller |
                 ++----------++
                  |          |
                  |          |
             +----++        ++----+
 -------     | ToF |        | ToF |
    |        +--+--+        +-----+
    |        |  |           |     |
    |        |  +-------------+   |
    |        |     +--------+ |   |
    |        |     |          |   |
             +-----+        +-+---+
RIFT domain  |SPINE|        |SPINE|
             +--+--+        +-----+
    |        |  |           |     |
    |        |  +-------------+   |
    |        |     +--------+ |   |
    |        |     |          |   |
    |        +-----+        +-+---+
 -------     |LEAF |        | LEAF|
             +-----+        +-----+
          ]]></artwork>
        </figure>
    <section><name>Controller Attached to ToF</name>
        <t>If a controller is attached to the RIFT domain at the ToF level, it should be multihomed.  The controller's loopback prefix should be advertised southbound by the ToF and spine nodes to the leaves.  If a controller loses a link to a ToF node, it is important to ensure that the controller be unreachable from that ToF node (this may require the use of a separate mechanism).</t>
    </section>
    <section><name>Controller Attached to Leaf</name>
        <t>Controller's attached to leaf nodes required no special consideration.
        </t>
    </section>

</section>

    <section><name>Internet Connectivity with Underlay</name>
	<t>If global addressing is required without the use of an overlay, an external default route needs to be advertised through the RIFT fabric to achieve internet access.  A more specific route describing the RIFT fabric should also be advertised by ToF and spine nodes in a Prefix S-TIE so not to impact forwarding for the rest of the fabric.</t>
        <section><name>Internet Default on the Leaf</name>
            <t>In cases where internet access is required for leaf nodes and the gateway is attached to another leaf, the leaf node terminating the gateway should advertise a defualt route in its Prefix N-TIEs.</t>
        </section>
        <section><name>Internet Default on the ToFs</name>
            <t>In cases where internet access is required for leaf nodes and the gateway is attached to a ToF node, both the ToF and spine nodes should advertise a default route in their Prefix S-TIEs.</t>
        </section>
    </section>

<section><name>Subnet Mismatches</name>

    <figure align='center' anchor='subnet-mismatch'><name>Subnet mismatch</name>
        <artwork align='center'>
        <![CDATA[

+--------+                     +--------+
|        |  LIE          LIE   |        |
|   A    | +---->       <----+ |   B    |
|        +---------------------+        |
+--------+                     +--------+
   X/24                           Y/24

]]></artwork>
        </figure><t keepWithPrevious='true'></t>

    <t>As shown in the above figure, without further checks adjacency of
    node A and B may form, but the forwarding between node A and node B
    may fail because subnet X mismatches with subnet Y.  This would be true 
    for any address family.
    </t>
    <t>To prevent this, a RIFT implementation should check for subnet
    mismatches (e.g. how IS-IS does).  This can lead to scenarios where
    an adjacency, despite exchange of LIEs in both address families may
    end up having an adjacency with a single AF only.  This is a
    consideration especially in <xref target='v4ov6'/> scenarios.
    </t>
</section>

<section><name>Anycast Considerations</name>
    <figure align='center' anchor='AnycastTL'><name>Anycast</name>
        <artwork align='center'><![CDATA[
                        + traffic
                        |
                        v
                 +------+------+
                 |     ToF     |
                 +---+-----+---+
                 |   |     |   |
    +------------+   |     |   +------------+
    |                |     |                |
+---+---+    +-------+     +-------+    +---+---+
|       |    |       |     |       |    |       |
|Spine11|    |Spine12|     |Spine21|    |Spine22| LEVEL 1
+-+---+-+    ++----+-+     +-+---+-+    ++----+-+
  |   |       |    |         |   |       |    |
  |   +---------+  |         |   +---------+  |
  |           | |  |         |           | |  |
  |   +-------+ |  |         |   +-------+ |  |
  |   |         |  |         |   |         |  |
+-+---+-+    +--+--+-+     +-+---+-+    +--+--+-+
|       |    |       |     |       |    |       |
|Leaf111|    |Leaf112|     |Leaf121|    |Leaf122| LEVEL 0
+-+-----+    ++------+     +-----+-+    +-----+-+
  +           +                  +      ^     |
PrefixA      PrefixB         PrefixA    | PrefixC
                                        |
                                        + traffic
            ]]></artwork>
        </figure>
    <t>RIFT handles anycast traffic natively in most scenarios (for example, traffic ingressing ToF nodes toward PrefixA hosted by Leaf111 and Leaf121).  However, in scenarios where anycasted traffic ingresses Leaf122 toward PrefixA, Spine21 and Spine22 will have no way of knowing that Leaf111 should also receive traffic for PrefixA, this results in Leaf121 receiving all traffic.  To manage this problem, policy guided prefixes should be implemented.
    </t>
</section>


</section>


<section anchor='Acknowledgements'><name>Acknowledgements</name>
     <t></t>

</section>

<section anchor='Contributors'><name>Contributors</name>
    <t>The following people (listed in alphabetical order) contributed significantly to the content of this document and should be considered co-authors:</t>
    <t>Tony Przygienda</t>
    <t>Juniper Networks</t>
    <t>1194 N. Mathilda Ave</t>
    <t>Sunnyvale, CA  94089</t>
    <t>US</t>
    <t>Email: prz@juniper.net</t>
</section>

</middle>
<back>

   <displayreference   target="I-D.ietf-rift-rift"        to="RIFT"/>

<references><name>Normative References</name>
<reference anchor='ISO10589-Second-Edition'>

    <front>
    <title>Intermediate system to Intermediate system intra-domain
    routeing information exchange protocol for use in
    conjunction with the protocol for providing the
    connectionless-mode Network Service (ISO 8473)</title>

    <author>
        <organization>International Organization for Standardization</organization>
    </author>
    <date month='Nov' year='2002'/>
    </front>
</reference>

<reference anchor='TR-384'>
    <front>
        <title>TR-384 Cloud Central Office Reference Architectural Framework</title>
        <author>
            <organization>Broadband Forum Technical Report</organization>
        </author>
        <date month='Jan' year='2018'/>
    </front>
</reference>


<xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2328.xml'/>
<xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4861.xml'/>
<xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5357.xml'/>
<xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7130.xml'/>

<xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-rift-rift.xml'/>
<xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.white-distoptflood.xml'/>
</references>

<references><name>Informative References</name>
<xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5905.xml'/>
<xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8200.xml'/>
<xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8505.xml'/>
</references>

</back>

</rfc>